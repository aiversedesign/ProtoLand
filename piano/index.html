<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project • ProtoLand</title>
  <link rel="stylesheet" href="./styles.css" />
  <script defer src="./data.js"></script>
</head>
<body>
  <header class="appbar">
    <div class="appbar-inner">
      <a class="brand" href="../">ProtoLand</a>
      <div id="project-title" class="project-title">Project</div>
    </div>
  </header>

  <main>
    <section class="hero">
      <h1 id="hero-title">Project Title</h1>
      <p id="hero-description">Short description of the project.</p>
    </section>
    <section class="content">
      <div class="controls">
        <div class="control">Keys: <code>ASDFGHJK</code> for white, <code>WETYU</code> for black</div>
        <div class="control">Octave: <code>Z</code>↓ <code>X</code>↑</div>
        <div class="control">Sustain: <label><input id="sustain" type="checkbox" /> hold</label></div>
      </div>

      <div class="piano-wrap">
        <div id="piano" class="piano" role="application" aria-label="Interactive piano keyboard"></div>
        <div class="legend">Click keys or use your computer keyboard.</div>
      </div>
    </section>
  </main>

  <footer class="footer">© 2025 ProtoLand</footer>

  <script>
    (function () {
      if (!window.PROJECT_DATA) return;
      const { title, description } = window.PROJECT_DATA;
      if (title) {
        document.title = `${title} • ProtoLand`;
        const elTitle = document.getElementById('project-title');
        const hero = document.getElementById('hero-title');
        if (elTitle) elTitle.textContent = title;
        if (hero) hero.textContent = title;
      }
      if (description) {
        const desc = document.getElementById('hero-description');
        if (desc) desc.textContent = description;
      }
    })();
  </script>
  <script>
    (function () {
      const WHITE_KEYS = ['A','S','D','F','G','H','J','K'];
      const BLACK_KEYS = ['W','E','T','Y','U'];
      const SEMITONES_WHITE = [0,2,4,5,7,9,11,12];
      const SEMITONES_BLACK = [1,3,6,8,10];
      const PIANO_OCTAVES = 2; // visible white keys length maps across two octaves
      let baseOctave = 4; // adjustable with Z/X

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = audioContext.createGain();
      masterGain.gain.value = 0.12;
      masterGain.connect(audioContext.destination);

      const activeNotes = new Map(); // midi -> {osc, gain}
      const sustainEl = document.getElementById('sustain');

      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function playMidi(midi) {
        if (activeNotes.has(midi)) return;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const now = audioContext.currentTime;

        osc.type = 'sine';
        osc.frequency.value = midiToFreq(midi);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(1, now + 0.005);
        gain.gain.linearRampToValueAtTime(0.85, now + 0.03);

        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();

        activeNotes.set(midi, { osc, gain });
      }

      function stopMidi(midi) {
        const note = activeNotes.get(midi);
        if (!note) return;
        const { osc, gain } = note;
        const now = audioContext.currentTime;
        const release = 0.15;
        gain.gain.cancelScheduledValues(now);
        gain.gain.setTargetAtTime(0, now, release);
        setTimeout(() => {
          try { osc.stop(); } catch (e) {}
          osc.disconnect();
          gain.disconnect();
        }, 400);
        activeNotes.delete(midi);
      }

      function noteForWhiteIndex(index) {
        const octaveOffset = Math.floor(index / SEMITONES_WHITE.length);
        const within = index % SEMITONES_WHITE.length;
        const semitone = SEMITONES_WHITE[within] + (octaveOffset * 12);
        const midi = 12 * (baseOctave + 1) + semitone; // C octave
        return midi;
      }

      function noteForBlackPosition(pos) {
        // map 5 black keys across each octave; positions relative to whites
        const midi = 12 * (baseOctave + 1) + SEMITONES_BLACK[pos % 5] + Math.floor(pos / 5) * 12;
        return midi;
      }

      function renderPiano() {
        const root = document.getElementById('piano');
        if (!root) return;
        root.innerHTML = '';

        const totalWhite = SEMITONES_WHITE.length * PIANO_OCTAVES;

        // White keys
        const whites = document.createElement('div');
        whites.className = 'keys-white';
        for (let i = 0; i < totalWhite; i++) {
          const key = document.createElement('div');
          key.className = 'key white';
          key.dataset.index = String(i);
          const label = document.createElement('div');
          label.className = 'key-label';
          const legend = WHITE_KEYS[i % WHITE_KEYS.length] || '';
          label.textContent = legend;
          key.appendChild(label);
          whites.appendChild(key);
        }
        root.appendChild(whites);

        // Black keys positioning (relative percentages for standard layout)
        const blacks = document.createElement('div');
        blacks.className = 'keys-black';
        const pattern = [0.66, 1.66, 3.66, 4.66, 5.66]; // position over whites per octave
        const perWhite = 100 / totalWhite;

        for (let octave = 0; octave < PIANO_OCTAVES; octave++) {
          for (let p = 0; p < pattern.length; p++) {
            const left = (octave * SEMITONES_WHITE.length + pattern[p]) * perWhite;
            const key = document.createElement('div');
            key.className = 'key black';
            key.style.left = `calc(${left}% - 3.25%)`;
            key.dataset.blackPos = String(octave * pattern.length + p);
            const label = document.createElement('div');
            label.className = 'key-label';
            const legend = BLACK_KEYS[p % BLACK_KEYS.length] || '';
            label.textContent = legend;
            key.appendChild(label);
            blacks.appendChild(key);
          }
        }
        root.appendChild(blacks);

        // Mouse interactions
        root.addEventListener('mousedown', onPointerDown);
        root.addEventListener('mouseup', onPointerUp);
        root.addEventListener('mouseleave', onPointerUp);
      }

      function onPointerDown(e) {
        const target = e.target.closest('.key');
        if (!target) return;
        const isBlack = target.classList.contains('black');
        if (isBlack) {
          const pos = Number(target.dataset.blackPos);
          const midi = noteForBlackPosition(pos);
          playMidi(midi);
          target.classList.add('active');
          target.dataset.midi = String(midi);
        } else {
          const idx = Number(target.dataset.index);
          const midi = noteForWhiteIndex(idx);
          playMidi(midi);
          target.classList.add('active');
          target.dataset.midi = String(midi);
        }
      }

      function onPointerUp(e) {
        const keys = document.querySelectorAll('.key.active');
        keys.forEach((el) => {
          const midi = Number(el.dataset.midi);
          if (!sustainEl.checked) stopMidi(midi);
          el.classList.remove('active');
          delete el.dataset.midi;
        });
      }

      const KEY_TO_WHITE_IDX = new Map(WHITE_KEYS.map((k, i) => [k, i]));
      const KEY_TO_BLACK_POS = new Map(BLACK_KEYS.map((k, i) => [k, i]));

      function handleKeyDown(ev) {
        const key = ev.key.toUpperCase();
        if (key === 'Z') { baseOctave = Math.max(1, baseOctave - 1); renderPiano(); return; }
        if (key === 'X') { baseOctave = Math.min(7, baseOctave + 1); renderPiano(); return; }
        if (key === ' ') { sustainEl.checked = !sustainEl.checked; ev.preventDefault(); return; }

        if (KEY_TO_WHITE_IDX.has(key)) {
          const idx = KEY_TO_WHITE_IDX.get(key);
          const midi = noteForWhiteIndex(idx);
          playMidi(midi);
          highlightWhite(idx, midi);
        } else if (KEY_TO_BLACK_POS.has(key)) {
          const pos = KEY_TO_BLACK_POS.get(key);
          const midi = noteForBlackPosition(pos);
          playMidi(midi);
          highlightBlack(pos, midi);
        }
      }

      function handleKeyUp(ev) {
        const key = ev.key.toUpperCase();
        if (KEY_TO_WHITE_IDX.has(key)) {
          const idx = KEY_TO_WHITE_IDX.get(key);
          const midi = noteForWhiteIndex(idx);
          if (!sustainEl.checked) removeWhite(idx, midi);
          if (!sustainEl.checked) stopMidi(midi);
        } else if (KEY_TO_BLACK_POS.has(key)) {
          const pos = KEY_TO_BLACK_POS.get(key);
          const midi = noteForBlackPosition(pos);
          if (!sustainEl.checked) removeBlack(pos, midi);
          if (!sustainEl.checked) stopMidi(midi);
        }
      }

      function highlightWhite(idx, midi) {
        const root = document.getElementById('piano');
        const el = root.querySelector(`.key.white[data-index="${idx}"]`);
        if (el) { el.classList.add('active'); el.dataset.midi = String(midi); }
      }
      function removeWhite(idx) {
        const root = document.getElementById('piano');
        const el = root.querySelector(`.key.white[data-index="${idx}"]`);
        if (el) { el.classList.remove('active'); delete el.dataset.midi; }
      }
      function highlightBlack(pos, midi) {
        const root = document.getElementById('piano');
        const el = root.querySelector(`.key.black[data-black-pos="${pos}"]`);
        if (el) { el.classList.add('active'); el.dataset.midi = String(midi); }
      }
      function removeBlack(pos) {
        const root = document.getElementById('piano');
        const el = root.querySelector(`.key.black[data-black-pos="${pos}"]`);
        if (el) { el.classList.remove('active'); delete el.dataset.midi; }
      }

      // Attach listeners
      window.addEventListener('keydown', (e) => {
        // avoid auto-repeat holding retriggering envelope
        if (e.repeat) return;
        handleKeyDown(e);
      });
      window.addEventListener('keyup', handleKeyUp);

      renderPiano();
    })();
  </script>
</body>
</html>


